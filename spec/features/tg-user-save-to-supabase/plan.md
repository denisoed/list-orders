# Implementation Plan

**Plan:** У нас есть серверная функция, которая принимает initData и валидирует его. Если валидация проходит успешно, то нужно парсить и сохранять пользователя в supabase в таблицу users используя server/utils/supabase.ts. Но нужно проверить, что если такой пользователь сохранен уже, то ничего не делать, не сохранять.

## Data sources / schemas

### Структура данных initData

- `initData` представляет собой строку в формате URL query parameters (например, `user=%7B%22id%22%3A123%2C%22first_name%22%3A%22John%22%7D&auth_date=1234567890&hash=...`).
- Параметр `user` содержит URL-encoded JSON-строку с данными пользователя Telegram.
- Объект пользователя в декодированном виде содержит поля: `id` (number), `first_name` (string), `last_name?` (string, опционально), `username?` (string, опционально), `language_code?` (string, опционально), `is_premium?` (boolean, опционально), `photo_url?` (string, опционально).

### Схема таблицы users в Supabase

- Предполагается, что таблица `users` существует и имеет следующие колонки:
  - `telegram_id` (bigint, primary key или unique) - уникальный идентификатор пользователя из Telegram
  - `first_name` (text, nullable) - имя пользователя
  - `last_name` (text, nullable) - фамилия пользователя
  - `username` (text, nullable) - username пользователя в Telegram
  - `language_code` (text, nullable) - код языка пользователя
  - `is_premium` (boolean, nullable) - флаг наличия Telegram Premium
  - `photo_url` (text, nullable) - URL фотографии профиля
  - `created_at` (timestamp, default now()) - дата создания записи
  - `updated_at` (timestamp, default now()) - дата последнего обновления

- Для проверки существования пользователя используется колонка `telegram_id` с уникальным индексом.

### Миграции базы данных

- Не требуется создание новых миграций, так как таблица `users` предположительно уже существует.
- Если таблица не существует, необходимо создать миграцию для создания таблицы и необходимых индексов.

## Contracts and interfaces

### Изменения в существующем API endpoint

- **Endpoint**: `POST /api/telegram/validate-init-data`
- **Request**: без изменений - `{ initData: string }`
- **Response**: без изменений - `{ success: boolean }` или ошибка валидации
- **Побочные эффекты**: после успешной валидации выполняется попытка сохранения пользователя в Supabase (не влияет на ответ API)

### Интерфейс функции парсинга initData

```typescript
interface TelegramUser {
  id: number
  first_name: string
  last_name?: string
  username?: string
  language_code?: string
  is_premium?: boolean
  photo_url?: string
}

function parseInitDataUser(initData: string): TelegramUser | null
```

- Принимает строку `initData`, парсит query-параметры, извлекает параметр `user`, декодирует URL-encoding и парсит JSON.
- Возвращает объект пользователя или `null`, если парсинг не удался.

### Интерфейс функции сохранения пользователя

```typescript
async function saveUserToSupabase(user: TelegramUser): Promise<void>
```

- Принимает объект пользователя Telegram.
- Получает клиент Supabase через `getSupabaseClient()`.
- Проверяет существование пользователя по `telegram_id`.
- Если пользователь не существует, выполняет вставку новой записи.
- Логирует все операции и ошибки.

### Обработка ошибок

- Ошибки парсинга и сохранения логируются, но не возвращаются клиенту.
- Используется префикс `[Telegram User Save]` для всех логов, связанных с сохранением пользователя.

## Architecture / Components

### Компоненты реализации

1. **Функция парсинга initData** (`parseInitDataUser`)
   - Разбор query-параметров из строки `initData`
   - Декодирование URL-encoded параметра `user`
   - Парсинг JSON-строки в объект пользователя
   - Обработка ошибок парсинга

2. **Функция сохранения пользователя** (`saveUserToSupabase`)
   - Получение клиента Supabase через `getSupabaseClient()`
   - Проверка существования пользователя через `select().eq('telegram_id', user.id).single()` - значение поля `id` из объекта пользователя используется для сравнения с полем `telegram_id` в таблице `users`
   - Обработка результата проверки (найден/не найден)
   - Вставка новой записи через `insert()` если пользователь не найден, где поле `id` из объекта пользователя маппится в поле `telegram_id` в таблице `users`
   - Логирование всех операций

3. **Интеграция в существующий endpoint**
   - Модификация `server/api/telegram/validate-init-data.post.ts`
   - Добавление вызова `saveUserToSupabase` после успешной валидации
   - Сохранение текущего поведения API (не нарушение контракта)

### Зависимости

- `@supabase/supabase-js` - уже используется через `server/utils/supabase.ts`
- `@telegram-apps/init-data-node` - уже используется для валидации
- Встроенные модули Node.js: `URLSearchParams`, `decodeURIComponent`, `JSON.parse`

### Обработка ошибок Supabase

- При проверке существования: ошибка с кодом `PGRST116` (или аналогичная) означает, что запись не найдена - это нормальная ситуация.
- Другие ошибки при проверке логируются как предупреждения, но не прерывают выполнение.
- Ошибки при вставке логируются, но не возвращаются клиенту.

## Risks

1. **Риск нарушения существующего контракта API**
   - **Митигация**: Все операции сохранения выполняются асинхронно и не влияют на возвращаемый ответ API. Ошибки сохранения логируются, но не прерывают основной поток.

2. **Риск race condition при одновременных запросах**
   - **Описание**: Если два запроса с одинаковым пользователем приходят одновременно, оба могут не найти пользователя и попытаться вставить запись.
   - **Митигация**: Использование уникального индекса на `telegram_id` в таблице `users` обеспечит, что вторая вставка завершится с ошибкой уникальности, которую можно обработать корректно.

3. **Риск отсутствия таблицы users или неправильной схемы**
   - **Митигация**: Проверка наличия таблицы перед реализацией, обработка ошибок Supabase с информативными сообщениями в логах.

4. **Риск некорректного формата initData**
   - **Митигация**: Парсинг выполняется в try-catch блоке, все ошибки логируются. Если парсинг не удался, функция сохранения просто не выполняется, но это не влияет на валидацию.

5. **Риск снижения производительности endpoint**
   - **Митигация**: Операции с базой данных выполняются асинхронно. Можно добавить таймаут для операций с Supabase, чтобы не блокировать ответ слишком долго.

## Assumptions

- Таблица `users` существует в Supabase с необходимой структурой колонок и уникальным индексом на `telegram_id`.
- Клиент Supabase из `server/utils/supabase.ts` имеет права на чтение и запись в таблицу `users`.
- Формат `initData` соответствует стандартному формату Telegram WebApp initData с параметром `user` в виде URL-encoded JSON-строки.
- Пакет `@telegram-apps/init-data-node` не предоставляет готовой функции парсинга, поэтому парсинг выполняется вручную.
- Текущий API endpoint должен продолжать работать как раньше, сохранение пользователя - это внутренняя операция, не влияющая на публичный контракт API.

