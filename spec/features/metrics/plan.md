# Implementation Plan

**Plan:** Реализовать модуль метрик для владельца проектов: подготовить агрегирующие запросы/представления по таблицам Supabase (`projects`, `orders`, `order_history`, `order_reminder_logs`, `project_members`), спроектировать API-контракты и интерфейс дашборда, позволяющие отображать ключевые показатели по эффективности, срокам, нагрузке и финансам.

## Data sources / schemas
- Создать SQL-представления или материализованные представления для основных блоков метрик:
  - `project_metrics_view`: агрегаты по проектам (количество активных/архивных, completed/total, дата последнего обновления).
  - `order_status_metrics_view`: количество заказов по статусам, темп поступления и закрытия (по `orders` и `order_history`).
  - `order_timing_metrics_view`: вычисление просрочек, среднего времени цикла, доли задач завершённых вовремя (использует `orders.due_date`, `orders.created_at`, события `status.done`).
  - `team_workload_view`: активные заказы по исполнителям (`orders.assignee_telegram_id` + join `project_members`).
  - `financial_metrics_view`: суммы `total_amount`, `prepayment_amount`, доля неопределённых оплат.
  - `review_metrics_view`: возвраты на доработку (`review_answer`, события `status.review`).
  - `reminder_metrics_view`: количество и эффективность напоминаний (`order_reminder_logs`, последующие изменения статуса).
- Для расчётов времени по статусам расширить `order_history` выборками с оконными функциями (ROW_NUMBER, LAG) для нахождения интервалов между событиями.
- Продумать индексацию/оптимизацию запросов: убедиться, что используемые поля имеют индексы (created_at, status, due_date, order_id).

## Contracts and interfaces
- API слой: REST или RPC эндпоинт `/api/metrics` с параметрами `projectId`, `from`, `to`. Возвращает объект с разделами `project`, `orders`, `timing`, `team`, `finance`, `quality`, `reminders`.
- Для каждого раздела описать формат ответа (ключи, типы, единицы измерения). Например, `orders.statusBreakdown: Array<{ status: string; count: number; trend: number }>`.
- Обработать фильтры: поддержать `projectId=all` (портфель) и периоды (date range). Валидация входных параметров на сервере.
- UI контракт: компонент дашборда ожидает агрегированные данные и отображает карточки + графики (линейные/столбчатые). Описать требуемые поля для визуализации (например, `chart.series`, `value`, `delta`).
- Ошибки: возвращать структурированный ответ `{ error: { code, message } }` при проблемах (нет доступа, некорректный период).

## Architecture / Components
- Backend (Supabase Edge Function или серверный маршрут Nuxt): собирает данные из SQL-представлений и кеширует в Redis/Memory на 5 минут.
- Frontend: Nuxt страница `/projects/:id/metrics` с виджетами (cards, charts, tables), доступная из вкладки «Метрики» на странице редактирования проекта. Использовать существующие UI-компоненты и сохранять параметры возврата.
- Слой данных: модуль-репозиторий, инкапсулирующий запросы к Supabase и трансформацию в DTO.
- Фильтрация/сортировка: глобальный фильтр периода и проекта, влияющий на все виджеты через store/composable.
- Логирование: мониторинг запросов к Supabase, замер времени выполнения, отправка в существующую систему логов (если есть).

## Risks
- Высокая нагрузка на базу при одновременном выполнении сложных агрегатов → смягчать кешированием и материализованными представлениями.
- Неполные или некорректные данные (пустые due_date, отсутствие событий в `order_history`) → предусмотреть fallback и явные подсказки в UI.
- Возможные расхождения между полями `orders.status` и историей → требуется согласование бизнес-логики обновления статусов.
- Сложность интерпретации финансовых показателей без явного признака оплаты → риск неправильных выводов владельца.

## Assumptions
- Допустимо расширить схему Supabase дополнительными представлениями/функциями без модификации основных таблиц.
- API для метрик можно реализовать на существующей инфраструктуре (Edge Functions или server routes) без выделения отдельного сервиса.
- Готовность UI-команды адаптировать текущие компоненты карточек/графиков под новые данные.
- Для расчёта эффективности напоминаний достаточно анализировать изменение статусов в течение 24 часов после `order_reminder_logs.sent_at`.
