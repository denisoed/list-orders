# Implementation Plan

**Plan:** нужно создать новую динамическую страницу деталей заказа. Она будет открываться при нажатии на карточку заказа.

## Data sources / schemas
- Определить источник данных для деталей заказа: переиспользовать существующий composable или создать новый метод в `data/orders` для получения расширенных данных по идентификатору.
- Согласовать схему ответа API: поля заказа (id, номер, статус, даты, клиент, адрес, сумма, валюты), массив позиций (наименование, количество, цена), вложения (тип, ссылка, размер), история (actor, действие, timestamp).
- При необходимости расширить мок-данные или JSON-файлы в `data` для локальной разработки и тестов.
- Добавить типы/интерфейсы для деталей заказа в `types` или соответствующем модуле, чтобы обеспечить типизацию в Vue/Nuxt.

## Contracts and interfaces
- Маршрут `/orders/[id].vue` должен принимать параметр `id` и вызывать загрузку данных при монтировании и при изменении параметра.
- Определить интерфейсы методов загрузки (например, `fetchOrderDetails(id: string)`), обработку ошибок (возврат объекта с признаком ошибки и сообщением).
- Спроектировать компоненты интерфейса: заголовок с кнопкой возврата, карточки основных сведений, секция позиций, история, вложения, действия. Проверить, можно ли переиспользовать существующие компоненты карточек и списков.
- Настроить события взаимодействия: кнопка "Назад" возвращает к списку, действия (например, "Отметить выполненным") вызывают соответствующие обработчики или emit событий.

## Architecture / Components
- Создать динамическую страницу `pages/orders/[id].vue`, подключить layout и composables приложения.
- Разбить страницу на секции с переиспользованием Tailwind-классов и существующей дизайн-системы: верхний бар, основные сведения, статусные бейджи, товары, контакты, описание/комментарии, вложения, история, футер с действиями.
- Реализовать состояние загрузки и ошибки с помощью `useAsyncData`/`useFetch`, добавить Skeleton/placeholder компоненты.
- Интегрировать переключение тем (светлая/тёмная) и адаптивность через Tailwind контейнерные запросы или брейкпоинты.
- Обеспечить реактивное обновление при изменении данных (например, после действий пользователя) с помощью хранилища или обновления `useAsyncData`.

## Risks
- Возможное несоответствие формата API и потребностей UI — требуется уточнение или трансформация данных.
- Производительность при большом количестве позиций в заказе — нужно предусмотреть виртуализацию или пагинацию, если список превышает допустимые размеры.
- Несогласованность дизайна с остальными частями приложения — нужна проверка макетов и консультация с дизайнером.
- Отсутствие реальных данных для истории или вложений может привести к пустым блокам — нужно предусмотреть fallback-сообщения.

## Assumptions
- Действия по изменению статуса реализуются на отдельном API и будут подключены позже; сейчас достаточно заглушек.
- Все данные доступны через один API вызов; дополнительных запросов не требуется.
- Пользователи имеют права на просмотр деталей заказа по клику из списка.
